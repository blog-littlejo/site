+++
date = '2025-07-21T07:43:35+02:00'
#lastmod = '2025-07-22T07:43:35+02:00'
draft = true
title = "uProbe : l'observabilit√© pour tous les d√©veloppeurs"
series = ["Apprenons uProbe avec eBPF et Aya", "Apprenons un autre programme eBPF"]
tags = ["Rust", "eBPF", "aya", "intro"]
summary = "Nous allons voir les bases des programmes eBPF de type uProbe et uRetProbes avec Aya"
series_order = 1
+++

Je d√©bute la programmation en eBPF avec Aya. L‚Äôid√©e de cette s√©rie d‚Äôarticles est d'apprendre un nouveau type de programme eBPF et de l'exp√©rimenter avec le framework Rust Aya.

Aujourd'hui nous allons nous plonger dans les **uProbes** et les **uRetProbes** : des programmes eBPF qui sondent les fonctions de l'espace utilisateur.

Si tu ne connais pas eBPF, je te conseille de lire les deux premi√®res parties de ma s√©rie [S‚Äôinitier √† eBPF avec Aya](https://medium.com/@littel.jo/sinitier-%C3%A0-ebpf-avec-aya-c9d570560261). Cela couvre les bases et t'aidera pour la suite de l'article.

---

# Qu'est-ce qu'un u‚Ä¢Ret‚Ä¢Probe ?

En anglais, une *probe* est une sonde pour examiner ou explorer quelque chose.

## Dans la famille des probes, je demande

### kProbe

Si tu consultes la [documentation d'eBPF](https://docs.ebpf.io/linux/program-type/), il n'y a pas de section consacr√©e aux programmes de type uProbe ou uRetProbe. Mais il y a une d√©di√©e au [kProbe](https://docs.ebpf.io/linux/program-type/BPF_PROG_TYPE_KPROBE/) :

![Kprobe documentation](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/p04bcqi8orzc9pwpvvf1.png)

### uProbe

Contrairement aux **k**Probes qui sont d√©di√©es √† observer les fonctions du **k**ernel Linux, les **u**Probes sont d√©di√©s aux fonctions de l'espace utilisateur : *User Probes*.

## uProbe et uRetProbe : les ins√©parables ?

u**Ret**Probe a pour but d'√©tudier le **ret**our de la fonction cible : *User Return Probes*. Ainsi en ayant les temps du uProbe et du uRetProbe, on peut avoir la dur√©e que met une fonction √† s'ex√©cuter assez facilement. Il est ainsi possible de tracer chaque fonction de son programme. On pourrait par exemple l'utiliser pour des requ√™tes SQL o√π on identifierait les requ√™tes les plus longues.

## Autres int√©r√™ts des u‚Ä¢Ret‚Ä¢Probes

uProbe permet √©galement de r√©cup√©rer le contenu des arguments de chaque fonction appel√©e et d√©bugger un programme dont tu n'as pas le code source. √áa peut donc √™tre un bel outil de reverse engineering.

Pour finir la pr√©sentation, √ßa peut para√Ætre paradoxal de vouloir tracer un code utilisateur depuis l'espace noyau. Cependant cela a le m√©rite d'√™tre non intrusif car il n'y a pas besoin de modifier le programme.


---

# Origin story

## uTrace l'anc√®tre

Vouloir tracer des fonctions de l'espace utilisateur depuis le kernel linux ne date pas de l'introduction d'eBPF. Par exemple, une (premi√®re ?) tentative est apparue en 2007 avec les utraces :

[![Introducing utrace](screenshot/utrace.png)](https://lwn.net/Articles/224772/)

Mais ils n'ont jamais √©t√© inclus dans le code principal √† cause d'opposition de certains mainteneurs.

## Habemus uProbe

En 2012, le consensus a fini par arriver et les uProbes ont √©t√© introduites lors la version 3.5 du noyau Linux :

[![Introducing uprobe](screenshot/uprobe-history.png)](https://lwn.net/Articles/499190/)

Ils ont ensuite √©t√© am√©lior√©s avec la version 3.14 (sortie en 2014) :

[![Patching uprobe](screenshot/uprobe-history-2.png)](https://lwn.net/Articles/577142/)

## uProbe avec eBPF : une naissance silencieuse

Je n'ai pas trouv√© la date exacte de l'apparition des uprobes avec eBPF. Dans la documentation de kprobe, kprobe est apparu dans la version 4.1 (sortie en 2015). En voici le commit :

[![Patching kprobe eBPF](screenshot/uprobe-history-3.png)](https://github.com/torvalds/linux/commit/2541517c32be2531e0da59dfd7efc1ce844644f5)

Mais il n'y a pas de trace pour la possibilit√© d'utiliser uprobe avec eBPF (si quelqu'un l'a trouv√©, je n'h√©siterai pas √† modifier l'article).
Cependant, on peut d√©j√† l'utiliser depuis 2016 comme le montre le tutoriel de Brendan Gregg : 

[![uprobe bcc eBPF tutorial](screenshot/uprobe-history-4.png)](https://www.brendangregg.com/blog/2016-02-08/linux-ebpf-bcc-uprobes.html)

Il suffit juste tourner sur une distribution Linux moderne pour exp√©rimenter cela.

Maintenant qu'on a pr√©sent√© uProbe et uRetProbe, voyons comment les manipuler un peu plus concr√®tement avec Aya.

---

# Comment trouver les hooks ?

Quand on d√©marre le d√©veloppement d'un nouveau programme eBPF, la premi√®re difficult√© est de r√©ussir √† le d√©marrer. Pour cela, il a besoin d'un √©v√©nement d√©clencheur (event-driven). Dans cet √©pisode, cet √©v√©nement sera le passage d'un uProbe et d'un uRetProbe dans le noyau Linux.

Aya nous facilite la t√¢che quand on lance la commande :
```Bash
cargo generate https://github.com/aya-rs/aya-template
```

Tu devras r√©pondre √† deux questions importantes qui permettront de d√©finir le hook :

```
ü§∑   Target to attach the (u|uret)probe? (e.g libc):
ü§∑   Function name to attach the (u|uret)probe? (e.g getaddrinfo):
```

La premi√®re bonne nouvelle c'est que les questions sont les m√™mes pour uProbe et uRetProbe.

Essayons de r√©pondre √† ces questions maintenant.

## Cible pour attacher le uProbe/uRetProbe

Pour la premi√®re question tu dois donner le nom d'une biblioth√®que (comme la libc) ou le nom d'un binaire (dans un chemin absolu). La question aurait pu √™tre pos√©e autrement : quel fichier tu veux debugger ou tracer ?

Il faut voir √ßa comme un filtre.
* Si tu choisis `libc`, tu auras toutes les chances que le programme eBPF tourne √† chaque fois qu'un programme qui utilise la biblioth√®que libc est d√©marr√©
* Si tu choisis un binaire, il ne fonctionnera que si le binaire est ex√©cut√©.

## Nom de la fonction pour attacher le uProbe/uRetProbe

La seconde question demande la fonction du binaire ou de la biblioth√®que que tu veux d√©bugger. Par exemple si tu √©cris un programme, tu peux mettre le nom d'une fonction du programme. Ainsi √† chaque fois que la fonction est appel√©e, le programme eBPF sera lanc√©. Si tu choisis quelque chose de beaucoup moins pr√©cis comme la biblioth√®que libc et si tu choisi le syscall execve le programme eBPF se lancera √† chaque fois qu'un programme qui utilise la libc s'ex√©cute. √áa arrivera beaucoup plus.

---

L'introduction aux programmes eBPF de type uProbe et uRetProbe est termin√©e. Dans les prochains √©pisodes, nous allons exp√©rimenter tout cela avec Aya.
